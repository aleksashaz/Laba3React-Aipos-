{"ast":null,"code":"var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar isArray = require('./isArray');\n\nvar forbidNewOperator = require('./isIdentity');\n\nvar is = require('./is');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' & ');\n}\n\nfunction intersection(types, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () {\n      return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Intersection(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Intersection);\n      }\n\n      path = path || [displayName];\n      assert(Intersection.is(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    return value;\n  }\n\n  Intersection.meta = {\n    kind: 'intersection',\n    types: types,\n    name: name,\n    identity: identity\n  };\n  Intersection.displayName = displayName;\n\n  Intersection.is = function (x) {\n    return types.every(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Intersection.update = function (instance, patch) {\n    return Intersection(assert.update(instance, patch));\n  };\n\n  return Intersection;\n}\n\nintersection.getDefaultName = getDefaultName;\nmodule.exports = intersection;","map":{"version":3,"sources":["/home/aleksashaz/Aipos/Laba3React-Aipos-/node_modules/tcomb/lib/intersection.js"],"names":["assert","require","isTypeName","isFunction","isArray","forbidNewOperator","is","getTypeName","isIdentity","getDefaultName","types","map","join","intersection","name","process","env","NODE_ENV","every","length","stringify","displayName","identity","Intersection","value","path","meta","kind","x","type","update","instance","patch","module","exports"],"mappings":"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","sourcesContent":["var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar isFunction = require('./isFunction');\nvar isArray = require('./isArray');\nvar forbidNewOperator = require('./isIdentity');\nvar is = require('./is');\nvar getTypeName = require('./getTypeName');\nvar isIdentity = require('./isIdentity');\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' & ');\n}\n\nfunction intersection(types, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Intersection(value, path) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Intersection);\n      }\n      path = path || [displayName];\n      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    return value;\n  }\n\n  Intersection.meta = {\n    kind: 'intersection',\n    types: types,\n    name: name,\n    identity: identity\n  };\n\n  Intersection.displayName = displayName;\n\n  Intersection.is = function (x) {\n    return types.every(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Intersection.update = function (instance, patch) {\n    return Intersection(assert.update(instance, patch));\n  };\n\n  return Intersection;\n}\n\nintersection.getDefaultName = getDefaultName;\nmodule.exports = intersection;\n\n"]},"metadata":{},"sourceType":"script"}