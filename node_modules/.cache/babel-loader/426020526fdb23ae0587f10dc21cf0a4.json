{"ast":null,"code":"var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nvar isArray = require('./isArray');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nvar forbidNewOperator = require('./forbidNewOperator');\n\nvar isUnion = require('./isUnion');\n\nvar isNil = require('./isNil');\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' | ');\n}\n\nfunction union(types, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () {\n      return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Union(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value;\n      }\n    }\n\n    var type = Union.dispatch(value);\n\n    if (!type && Union.is(value)) {\n      return value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Union);\n      }\n\n      path = path || [displayName];\n      assert(isFunction(type), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)';\n      });\n      path[path.length - 1] += '(' + getTypeName(type) + ')';\n    }\n\n    return create(type, value, path);\n  }\n\n  Union.meta = {\n    kind: 'union',\n    types: types,\n    name: name,\n    identity: identity\n  };\n  Union.displayName = displayName;\n\n  Union.is = function (x) {\n    return types.some(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Union.dispatch = function (x) {\n    // default dispatch implementation\n    for (var i = 0, len = types.length; i < len; i++) {\n      var type = types[i];\n\n      if (isUnion(type)) {\n        // handle union of unions\n        var t = type.dispatch(x);\n\n        if (!isNil(t)) {\n          return t;\n        }\n      } else if (is(x, type)) {\n        return type;\n      }\n    }\n  };\n\n  Union.update = function (instance, patch) {\n    return Union(assert.update(instance, patch));\n  };\n\n  return Union;\n}\n\nunion.getDefaultName = getDefaultName;\nmodule.exports = union;","map":{"version":3,"sources":["/home/aleksashaz/Aipos/Laba3React-Aipos-/node_modules/tcomb/lib/union.js"],"names":["assert","require","isTypeName","isFunction","getTypeName","isIdentity","isArray","create","is","forbidNewOperator","isUnion","isNil","getDefaultName","types","map","join","union","name","process","env","NODE_ENV","every","length","stringify","displayName","identity","Union","value","path","type","dispatch","meta","kind","x","some","i","len","t","update","instance","patch","module","exports"],"mappings":"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","sourcesContent":["var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar isFunction = require('./isFunction');\nvar getTypeName = require('./getTypeName');\nvar isIdentity = require('./isIdentity');\nvar isArray = require('./isArray');\nvar create = require('./create');\nvar is = require('./is');\nvar forbidNewOperator = require('./forbidNewOperator');\nvar isUnion = require('./isUnion');\nvar isNil = require('./isNil');\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' | ');\n}\n\nfunction union(types, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Union(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value;\n      }\n    }\n\n    var type = Union.dispatch(value);\n    if (!type && Union.is(value)) {\n      return value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Union);\n      }\n      path = path || [displayName];\n      assert(isFunction(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)'; });\n      path[path.length - 1] += '(' + getTypeName(type) + ')';\n    }\n\n    return create(type, value, path);\n  }\n\n  Union.meta = {\n    kind: 'union',\n    types: types,\n    name: name,\n    identity: identity\n  };\n\n  Union.displayName = displayName;\n\n  Union.is = function (x) {\n    return types.some(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Union.dispatch = function (x) { // default dispatch implementation\n    for (var i = 0, len = types.length; i < len; i++ ) {\n      var type = types[i];\n      if (isUnion(type)) { // handle union of unions\n        var t = type.dispatch(x);\n        if (!isNil(t)) {\n          return t;\n        }\n      }\n      else if (is(x, type)) {\n        return type;\n      }\n    }\n  };\n\n  Union.update = function (instance, patch) {\n    return Union(assert.update(instance, patch));\n  };\n\n  return Union;\n}\n\nunion.getDefaultName = getDefaultName;\nmodule.exports = union;\n\n"]},"metadata":{},"sourceType":"script"}