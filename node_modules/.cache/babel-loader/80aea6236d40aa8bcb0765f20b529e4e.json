{"ast":null,"code":"'use strict';\n\nvar t = require('tcomb');\n\nvar stringify = t.stringify;\nvar noobj = {};\nvar ValidationError = t.struct({\n  message: t.Any,\n  actual: t.Any,\n  expected: t.Any,\n  path: t.list(t.union([t.String, t.Number]))\n}, 'ValidationError');\n\nfunction getDefaultValidationErrorMessage(actual, expected, path) {\n  var expectedName = t.getTypeName(expected);\n  var to = path.length ? '/' + path.join('/') + ': ' + expectedName : expectedName;\n  return 'Invalid value ' + stringify(actual) + ' supplied to ' + to;\n}\n\nfunction getValidationErrorMessage(actual, expected, path, context) {\n  if (t.Function.is(expected.getValidationErrorMessage)) {\n    return expected.getValidationErrorMessage(actual, path, context);\n  } else {\n    return getDefaultValidationErrorMessage(actual, expected, path);\n  }\n}\n\nValidationError.of = function (actual, expected, path, context) {\n  return new ValidationError({\n    message: getValidationErrorMessage(actual, expected, path, context),\n    actual: actual,\n    expected: expected,\n    path: path\n  });\n};\n\nvar ValidationResult = t.struct({\n  errors: t.list(ValidationError),\n  value: t.Any\n}, 'ValidationResult');\n\nValidationResult.prototype.isValid = function () {\n  return !this.errors.length;\n};\n\nValidationResult.prototype.firstError = function () {\n  return this.isValid() ? null : this.errors[0];\n};\n\nValidationResult.prototype.toString = function () {\n  if (this.isValid()) {\n    return '[ValidationResult, true, ' + stringify(this.value) + ']';\n  } else {\n    return '[ValidationResult, false, (' + this.errors.map(function (err) {\n      return stringify(err.message);\n    }).join(', ') + ')]';\n  }\n};\n\nfunction validate(x, type, options) {\n  options = options || {};\n  var path = t.Array.is(options) ? options : options.path || [];\n  return new ValidationResult(recurse(x, type, path, options));\n}\n\nfunction recurse(x, type, path, options) {\n  if (t.isType(type)) {\n    return validators[type.meta.kind](x, type, path, options);\n  } else {\n    return validators.es6classes(x, type, path, options);\n  }\n}\n\nvar validators = validate.validators = {};\n\nvalidators.es6classes = function validateES6Classes(x, type, path, options) {\n  return {\n    value: x,\n    errors: x instanceof type ? [] : [ValidationError.of(x, type, path, options.context)]\n  };\n}; // irreducibles and enums\n\n\nvalidators.irreducible = validators.enums = function validateIrreducible(x, type, path, options) {\n  return {\n    value: x,\n    errors: type.is(x) ? [] : [ValidationError.of(x, type, path, options.context)]\n  };\n};\n\nvalidators.list = function validateList(x, type, path, options) {\n  // x should be an array\n  if (!t.Array.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: [],\n    errors: []\n  }; // every item should be of type `type.meta.type`\n\n  for (var i = 0, len = x.length; i < len; i++) {\n    var item = recurse(x[i], type.meta.type, path.concat(i), options);\n    ret.value[i] = item.value;\n    ret.errors = ret.errors.concat(item.errors);\n  }\n\n  return ret;\n};\n\nvalidators.subtype = function validateSubtype(x, type, path, options) {\n  // x should be a valid inner type\n  var ret = recurse(x, type.meta.type, path, options);\n\n  if (ret.errors.length) {\n    return ret;\n  } // x should satisfy the predicate\n\n\n  if (!type.meta.predicate(ret.value)) {\n    ret.errors = [ValidationError.of(x, type, path, options.context)];\n  }\n\n  return ret;\n};\n\nvalidators.maybe = function validateMaybe(x, type, path, options) {\n  return t.Nil.is(x) ? {\n    value: x,\n    errors: []\n  } : recurse(x, type.meta.type, path, options);\n};\n\nvalidators.struct = function validateStruct(x, type, path, options) {\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  } // [optimization]\n\n\n  if (type.is(x)) {\n    return {\n      value: x,\n      errors: []\n    };\n  }\n\n  var ret = {\n    value: {},\n    errors: []\n  };\n  var props = type.meta.props;\n  var defaultProps = type.meta.defaultProps || noobj; // every item should be of type `props[name]`\n\n  for (var name in props) {\n    if (props.hasOwnProperty(name)) {\n      var actual = x[name]; // apply defaults\n\n      if (actual === undefined) {\n        actual = defaultProps[name];\n      }\n\n      var prop = recurse(actual, props[name], path.concat(name), options);\n      ret.value[name] = prop.value;\n      ret.errors = ret.errors.concat(prop.errors);\n    }\n  }\n\n  var strict = options.hasOwnProperty('strict') ? options.strict : type.meta.strict;\n\n  if (strict) {\n    for (var field in x) {\n      if (x.hasOwnProperty(field) && !props.hasOwnProperty(field)) {\n        ret.errors.push(ValidationError.of(x[field], t.Nil, path.concat(field), options.context));\n      }\n    }\n  }\n\n  if (!ret.errors.length) {\n    ret.value = new type(ret.value);\n  }\n\n  return ret;\n};\n\nvalidators.tuple = function validateTuple(x, type, path, options) {\n  var types = type.meta.types;\n  var len = types.length; // x should be an array of at most `len` items\n\n  if (!t.Array.is(x) || x.length > len) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: [],\n    errors: []\n  }; // every item should be of type `types[i]`\n\n  for (var i = 0; i < len; i++) {\n    var item = recurse(x[i], types[i], path.concat(i), options);\n    ret.value[i] = item.value;\n    ret.errors = ret.errors.concat(item.errors);\n  }\n\n  return ret;\n};\n\nvalidators.dict = function validateDict(x, type, path, options) {\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: {},\n    errors: []\n  }; // every key should be of type `domain`\n  // every value should be of type `codomain`\n\n  for (var k in x) {\n    if (x.hasOwnProperty(k)) {\n      var subpath = path.concat(k);\n      var key = recurse(k, type.meta.domain, subpath, options);\n      var item = recurse(x[k], type.meta.codomain, subpath, options);\n      ret.value[k] = item.value;\n      ret.errors = ret.errors.concat(key.errors, item.errors);\n    }\n  }\n\n  return ret;\n};\n\nvalidators.union = function validateUnion(x, type, path, options) {\n  var ctor = type.dispatch(x);\n  return t.Function.is(ctor) ? recurse(x, ctor, path.concat(type.meta.types.indexOf(ctor)), options) : {\n    value: x,\n    errors: [ValidationError.of(x, type, path, options.context)]\n  };\n};\n\nvalidators.intersection = function validateIntersection(x, type, path, options) {\n  var types = type.meta.types;\n  var len = types.length;\n  var ret = {\n    value: x,\n    errors: []\n  };\n  var nrOfStructs = 0; // x should be of type `types[i]` for all i\n\n  for (var i = 0; i < len; i++) {\n    if (types[i].meta.kind === 'struct') {\n      nrOfStructs++;\n    }\n\n    var item = recurse(x, types[i], path, options);\n    ret.errors = ret.errors.concat(item.errors);\n  }\n\n  if (nrOfStructs > 1) {\n    ret.errors.push(ValidationError.of(x, type, path, options.context));\n  }\n\n  return ret;\n};\n\nvalidators['interface'] = function validateInterface(x, type, path, options) {\n  // eslint-disable-line dot-notation\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: {},\n    errors: []\n  };\n  var props = type.meta.props; // every item should be of type `props[name]`\n\n  for (var name in props) {\n    var prop = recurse(x[name], props[name], path.concat(name), options);\n    ret.value[name] = prop.value;\n    ret.errors = ret.errors.concat(prop.errors);\n  }\n\n  var strict = options.hasOwnProperty('strict') ? options.strict : type.meta.strict;\n\n  if (strict) {\n    for (var field in x) {\n      if (!props.hasOwnProperty(field) && !t.Nil.is(x[field])) {\n        ret.errors.push(ValidationError.of(x[field], t.Nil, path.concat(field), options.context));\n      }\n    }\n  }\n\n  return ret;\n};\n\nt.mixin(t, {\n  ValidationError: ValidationError,\n  ValidationResult: ValidationResult,\n  validate: validate\n});\nmodule.exports = t;","map":{"version":3,"sources":["/home/aleksashaz/Aipos/Laba3React-Aipos-/node_modules/tcomb-validation/index.js"],"names":["t","require","stringify","noobj","ValidationError","struct","message","Any","actual","expected","path","list","union","String","Number","getDefaultValidationErrorMessage","expectedName","getTypeName","to","length","join","getValidationErrorMessage","context","Function","is","of","ValidationResult","errors","value","prototype","isValid","firstError","toString","map","err","validate","x","type","options","Array","recurse","isType","validators","meta","kind","es6classes","validateES6Classes","irreducible","enums","validateIrreducible","validateList","ret","i","len","item","concat","subtype","validateSubtype","predicate","maybe","validateMaybe","Nil","validateStruct","Object","props","defaultProps","name","hasOwnProperty","undefined","prop","strict","field","push","tuple","validateTuple","types","dict","validateDict","k","subpath","key","domain","codomain","validateUnion","ctor","dispatch","indexOf","intersection","validateIntersection","nrOfStructs","validateInterface","mixin","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar t = require('tcomb');\nvar stringify = t.stringify;\n\nvar noobj = {};\n\nvar ValidationError = t.struct({\n  message: t.Any,\n  actual: t.Any,\n  expected: t.Any,\n  path: t.list(t.union([t.String, t.Number]))\n}, 'ValidationError');\n\nfunction getDefaultValidationErrorMessage(actual, expected, path) {\n  var expectedName = t.getTypeName(expected);\n  var to = path.length ? '/' + path.join('/') + ': ' + expectedName : expectedName;\n  return 'Invalid value ' + stringify(actual) + ' supplied to ' + to;\n}\n\nfunction getValidationErrorMessage(actual, expected, path, context) {\n  if (t.Function.is(expected.getValidationErrorMessage)) {\n    return expected.getValidationErrorMessage(actual, path, context);\n  }\n  else {\n    return getDefaultValidationErrorMessage(actual, expected, path);\n  }\n}\n\nValidationError.of = function (actual, expected, path, context) {\n  return new ValidationError({\n    message: getValidationErrorMessage(actual, expected, path, context),\n    actual: actual,\n    expected: expected,\n    path: path\n  });\n};\n\nvar ValidationResult = t.struct({\n  errors: t.list(ValidationError),\n  value: t.Any\n}, 'ValidationResult');\n\nValidationResult.prototype.isValid = function () {\n  return !(this.errors.length);\n};\n\nValidationResult.prototype.firstError = function () {\n  return this.isValid() ? null : this.errors[0];\n};\n\nValidationResult.prototype.toString = function () {\n  if (this.isValid()) {\n    return '[ValidationResult, true, ' + stringify(this.value) + ']';\n  }\n  else {\n    return '[ValidationResult, false, (' + this.errors.map(function (err) {\n      return stringify(err.message);\n    }).join(', ') + ')]';\n  }\n};\n\nfunction validate(x, type, options) {\n  options = options || {};\n  var path = t.Array.is(options) ? options : options.path || [];\n  return new ValidationResult(recurse(x, type, path, options));\n}\n\nfunction recurse(x, type, path, options) {\n  if (t.isType(type)) {\n    return validators[type.meta.kind](x, type, path, options);\n  }\n  else {\n    return validators.es6classes(x, type, path, options);\n  }\n}\n\nvar validators = validate.validators = {};\n\nvalidators.es6classes = function validateES6Classes(x, type, path, options) {\n  return {\n    value: x,\n    errors: x instanceof type ? [] : [ValidationError.of(x, type, path, options.context)]\n  };\n};\n\n// irreducibles and enums\nvalidators.irreducible =\nvalidators.enums = function validateIrreducible(x, type, path, options) {\n  return {\n    value: x,\n    errors: type.is(x) ? [] : [ValidationError.of(x, type, path, options.context)]\n  };\n};\n\nvalidators.list = function validateList(x, type, path, options) {\n\n  // x should be an array\n  if (!t.Array.is(x)) {\n    return {value: x, errors: [ValidationError.of(x, type, path, options.context)]};\n  }\n\n  var ret = {value: [], errors: []};\n  // every item should be of type `type.meta.type`\n  for (var i = 0, len = x.length; i < len; i++ ) {\n    var item = recurse(x[i], type.meta.type, path.concat(i), options);\n    ret.value[i] = item.value;\n    ret.errors = ret.errors.concat(item.errors);\n  }\n  return ret;\n};\n\nvalidators.subtype = function validateSubtype(x, type, path, options) {\n\n  // x should be a valid inner type\n  var ret = recurse(x, type.meta.type, path, options);\n  if (ret.errors.length) {\n    return ret;\n  }\n\n  // x should satisfy the predicate\n  if (!type.meta.predicate(ret.value)) {\n    ret.errors = [ValidationError.of(x, type, path, options.context)];\n  }\n\n  return ret;\n\n};\n\nvalidators.maybe = function validateMaybe(x, type, path, options) {\n  return t.Nil.is(x) ?\n    {value: x, errors: []} :\n    recurse(x, type.meta.type, path, options);\n};\n\nvalidators.struct = function validateStruct(x, type, path, options) {\n\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {value: x, errors: [ValidationError.of(x, type, path, options.context)]};\n  }\n\n  // [optimization]\n  if (type.is(x)) {\n    return {value: x, errors: []};\n  }\n\n  var ret = {value: {}, errors: []};\n  var props = type.meta.props;\n  var defaultProps = type.meta.defaultProps || noobj;\n  // every item should be of type `props[name]`\n  for (var name in props) {\n    if (props.hasOwnProperty(name)) {\n      var actual = x[name];\n      // apply defaults\n      if (actual === undefined) {\n        actual = defaultProps[name];\n      }\n      var prop = recurse(actual, props[name], path.concat(name), options);\n      ret.value[name] = prop.value;\n      ret.errors = ret.errors.concat(prop.errors);\n    }\n  }\n  var strict = options.hasOwnProperty('strict') ? options.strict : type.meta.strict;\n  if (strict) {\n    for (var field in x) {\n      if (x.hasOwnProperty(field) && !props.hasOwnProperty(field)) {\n        ret.errors.push(ValidationError.of(x[field], t.Nil, path.concat(field), options.context));\n      }\n    }\n  }\n  if (!ret.errors.length) {\n    ret.value = new type(ret.value);\n  }\n  return ret;\n};\n\nvalidators.tuple = function validateTuple(x, type, path, options) {\n\n  var types = type.meta.types;\n  var len = types.length;\n\n  // x should be an array of at most `len` items\n  if (!t.Array.is(x) || x.length > len) {\n    return {value: x, errors: [ValidationError.of(x, type, path, options.context)]};\n  }\n\n  var ret = {value: [], errors: []};\n  // every item should be of type `types[i]`\n  for (var i = 0; i < len; i++) {\n    var item = recurse(x[i], types[i], path.concat(i), options);\n    ret.value[i] = item.value;\n    ret.errors = ret.errors.concat(item.errors);\n  }\n  return ret;\n};\n\nvalidators.dict = function validateDict(x, type, path, options) {\n\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {value: x, errors: [ValidationError.of(x, type, path, options.context)]};\n  }\n\n  var ret = {value: {}, errors: []};\n  // every key should be of type `domain`\n  // every value should be of type `codomain`\n  for (var k in x) {\n    if (x.hasOwnProperty(k)) {\n      var subpath = path.concat(k);\n      var key = recurse(k, type.meta.domain, subpath, options);\n      var item = recurse(x[k], type.meta.codomain, subpath, options);\n      ret.value[k] = item.value;\n      ret.errors = ret.errors.concat(key.errors, item.errors);\n    }\n  }\n  return ret;\n};\n\nvalidators.union = function validateUnion(x, type, path, options) {\n  var ctor = type.dispatch(x);\n  return t.Function.is(ctor) ?\n    recurse(x, ctor, path.concat(type.meta.types.indexOf(ctor)), options) :\n    {value: x, errors: [ValidationError.of(x, type, path, options.context)]};\n};\n\nvalidators.intersection = function validateIntersection(x, type, path, options) {\n\n  var types = type.meta.types;\n  var len = types.length;\n\n  var ret = {value: x, errors: []};\n  var nrOfStructs = 0;\n  // x should be of type `types[i]` for all i\n  for (var i = 0; i < len; i++) {\n    if (types[i].meta.kind === 'struct') {\n      nrOfStructs++;\n    }\n    var item = recurse(x, types[i], path, options);\n    ret.errors = ret.errors.concat(item.errors);\n  }\n  if (nrOfStructs > 1) {\n    ret.errors.push(ValidationError.of(x, type, path, options.context));\n  }\n  return ret;\n};\n\nvalidators['interface'] = function validateInterface(x, type, path, options) { // eslint-disable-line dot-notation\n\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {value: x, errors: [ValidationError.of(x, type, path, options.context)]};\n  }\n\n  var ret = {value: {}, errors: []};\n  var props = type.meta.props;\n  // every item should be of type `props[name]`\n  for (var name in props) {\n    var prop = recurse(x[name], props[name], path.concat(name), options);\n    ret.value[name] = prop.value;\n    ret.errors = ret.errors.concat(prop.errors);\n  }\n  var strict = options.hasOwnProperty('strict') ? options.strict : type.meta.strict;\n  if (strict) {\n    for (var field in x) {\n      if (!props.hasOwnProperty(field) && !t.Nil.is(x[field])) {\n        ret.errors.push(ValidationError.of(x[field], t.Nil, path.concat(field), options.context));\n      }\n    }\n  }\n  return ret;\n};\n\nt.mixin(t, {\n  ValidationError: ValidationError,\n  ValidationResult: ValidationResult,\n  validate: validate\n});\n\nmodule.exports = t;\n"]},"metadata":{},"sourceType":"script"}