{"ast":null,"code":"var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isType = require('./isType');\n\nvar isNil = require('./isNil');\n\nvar mixin = require('./mixin');\n\nvar getTypeName = require('./getTypeName');\n\nvar isUnion = require('./isUnion'); // All the .declare-d types should be clearly different from each other thus they should have\n// different names when a name was not explicitly provided.\n\n\nvar nextDeclareUniqueId = 1;\n\nmodule.exports = function declare(name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)';\n    });\n  }\n\n  var type;\n\n  function Declare(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!isNil(type), function () {\n        return 'Type declared but not defined, don\\'t forget to call .define on every declared type';\n      });\n\n      if (isUnion(type)) {\n        assert(type.dispatch === Declare.dispatch, function () {\n          return 'Please define the custom ' + name + '.dispatch function before calling ' + name + '.define()';\n        });\n      }\n    }\n\n    return type(value, path);\n  }\n\n  Declare.define = function (spec) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isType(spec), function () {\n        return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a type)';\n      });\n      assert(isNil(type), function () {\n        return 'Declare.define(type) can only be invoked once';\n      }); // assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });\n    }\n\n    if (isUnion(spec) && Declare.hasOwnProperty('dispatch')) {\n      spec.dispatch = Declare.dispatch;\n    }\n\n    type = spec;\n    mixin(Declare, type, true); // true because it overwrites Declare.displayName\n\n    if (name) {\n      type.displayName = Declare.displayName = name;\n      Declare.meta.name = name;\n    }\n\n    Declare.meta.identity = type.meta.identity;\n    Declare.prototype = type.prototype;\n    return Declare;\n  };\n\n  Declare.displayName = name || getTypeName(Declare) + \"$\" + nextDeclareUniqueId++; // in general I can't say if this type will be an identity, for safety setting to false\n\n  Declare.meta = {\n    identity: false\n  };\n  Declare.prototype = null;\n  return Declare;\n};","map":{"version":3,"sources":["/home/aleksashaz/Aipos/Laba3React-Aipos-/node_modules/tcomb/lib/declare.js"],"names":["assert","require","isTypeName","isType","isNil","mixin","getTypeName","isUnion","nextDeclareUniqueId","module","exports","declare","name","process","env","NODE_ENV","type","Declare","value","path","dispatch","define","spec","stringify","hasOwnProperty","displayName","meta","identity","prototype"],"mappings":"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","sourcesContent":["var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar isType = require('./isType');\nvar isNil = require('./isNil');\nvar mixin = require('./mixin');\nvar getTypeName = require('./getTypeName');\nvar isUnion = require('./isUnion');\n\n// All the .declare-d types should be clearly different from each other thus they should have\n// different names when a name was not explicitly provided.\nvar nextDeclareUniqueId = 1;\n\nmodule.exports = function declare(name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)'; });\n  }\n\n  var type;\n\n  function Declare(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!isNil(type), function () { return 'Type declared but not defined, don\\'t forget to call .define on every declared type'; });\n      if (isUnion(type)) {\n        assert(type.dispatch === Declare.dispatch, function () { return 'Please define the custom ' + name + '.dispatch function before calling ' + name + '.define()'; });\n      }\n    }\n    return type(value, path);\n  }\n\n  Declare.define = function (spec) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (expected a type)'; });\n      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });\n      // assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });\n    }\n\n    if (isUnion(spec) && Declare.hasOwnProperty('dispatch')) {\n      spec.dispatch = Declare.dispatch;\n    }\n    type = spec;\n    mixin(Declare, type, true); // true because it overwrites Declare.displayName\n    if (name) {\n      type.displayName = Declare.displayName = name;\n      Declare.meta.name = name;\n    }\n    Declare.meta.identity = type.meta.identity;\n    Declare.prototype = type.prototype;\n    return Declare;\n  };\n\n  Declare.displayName = name || ( getTypeName(Declare) + \"$\" + nextDeclareUniqueId++ );\n  // in general I can't say if this type will be an identity, for safety setting to false\n  Declare.meta = { identity: false };\n  Declare.prototype = null;\n  return Declare;\n};\n"]},"metadata":{},"sourceType":"script"}