{"ast":null,"code":"var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar FunctionType = require('./Function');\n\nvar isArray = require('./isArray');\n\nvar list = require('./list');\n\nvar isObject = require('./isObject');\n\nvar create = require('./create');\n\nvar isNil = require('./isNil');\n\nvar isBoolean = require('./isBoolean');\n\nvar tuple = require('./tuple');\n\nvar getFunctionName = require('./getFunctionName');\n\nvar getTypeName = require('./getTypeName');\n\nvar isType = require('./isType');\n\nfunction getDefaultName(domain, codomain) {\n  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);\n}\n\nfunction isInstrumented(f) {\n  return FunctionType.is(f) && isObject(f.instrumentation);\n}\n\nfunction getOptionalArgumentsIndex(types) {\n  var end = types.length;\n  var areAllMaybes = false;\n\n  for (var i = end - 1; i >= 0; i--) {\n    var type = types[i];\n\n    if (!isType(type) || type.meta.kind !== 'maybe') {\n      return i + 1;\n    } else {\n      areAllMaybes = true;\n    }\n  }\n\n  return areAllMaybes ? 0 : end;\n}\n\nfunction func(domain, codomain, name) {\n  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(list(FunctionType).is(domain), function () {\n      return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)';\n    });\n    assert(FunctionType.is(codomain), function () {\n      return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(domain, codomain);\n  var domainLength = domain.length;\n  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);\n\n  function FuncType(value, path) {\n    if (!isInstrumented(value)) {\n      // automatically instrument the function\n      return FuncType.of(value);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(FuncType.is(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    return value;\n  }\n\n  FuncType.meta = {\n    kind: 'func',\n    domain: domain,\n    codomain: codomain,\n    name: name,\n    identity: true\n  };\n  FuncType.displayName = displayName;\n\n  FuncType.is = function (x) {\n    return isInstrumented(x) && x.instrumentation.domain.length === domainLength && x.instrumentation.domain.every(function (type, i) {\n      return type === domain[i];\n    }) && x.instrumentation.codomain === codomain;\n  };\n\n  FuncType.of = function (f, curried) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(FunctionType.is(f), function () {\n        return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)';\n      });\n      assert(isNil(curried) || isBoolean(curried), function () {\n        return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)';\n      });\n    }\n\n    if (FuncType.is(f)) {\n      // makes FuncType.of idempotent\n      return f;\n    }\n\n    function fn() {\n      var args = Array.prototype.slice.call(arguments);\n      var argsLength = args.length;\n\n      if (process.env.NODE_ENV !== 'production') {\n        // type-check arguments\n        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);\n        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);\n      }\n\n      if (curried && argsLength < domainLength) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName);\n        }\n\n        var g = Function.prototype.bind.apply(f, [this].concat(args));\n        var newDomain = func(domain.slice(argsLength), codomain);\n        return newDomain.of(g, true);\n      } else {\n        return create(codomain, f.apply(this, args));\n      }\n    }\n\n    fn.instrumentation = {\n      domain: domain,\n      codomain: codomain,\n      f: f\n    };\n    fn.displayName = getFunctionName(f);\n    return fn;\n  };\n\n  return FuncType;\n}\n\nfunc.getDefaultName = getDefaultName;\nfunc.getOptionalArgumentsIndex = getOptionalArgumentsIndex;\nmodule.exports = func;","map":{"version":3,"sources":["/home/aleksashaz/Aipos/Laba3React-Aipos-/node_modules/tcomb/lib/func.js"],"names":["assert","require","isTypeName","FunctionType","isArray","list","isObject","create","isNil","isBoolean","tuple","getFunctionName","getTypeName","isType","getDefaultName","domain","codomain","map","join","isInstrumented","f","is","instrumentation","getOptionalArgumentsIndex","types","end","length","areAllMaybes","i","type","meta","kind","func","name","process","env","NODE_ENV","stringify","displayName","domainLength","optionalArgumentsIndex","FuncType","value","path","of","identity","x","every","curried","fn","args","Array","prototype","slice","call","arguments","argsLength","tupleLength","Math","max","g","Function","bind","apply","concat","newDomain","module","exports"],"mappings":"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","sourcesContent":["var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar FunctionType = require('./Function');\nvar isArray = require('./isArray');\nvar list = require('./list');\nvar isObject = require('./isObject');\nvar create = require('./create');\nvar isNil = require('./isNil');\nvar isBoolean = require('./isBoolean');\nvar tuple = require('./tuple');\nvar getFunctionName = require('./getFunctionName');\nvar getTypeName = require('./getTypeName');\nvar isType = require('./isType');\n\nfunction getDefaultName(domain, codomain) {\n  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);\n}\n\nfunction isInstrumented(f) {\n  return FunctionType.is(f) && isObject(f.instrumentation);\n}\n\nfunction getOptionalArgumentsIndex(types) {\n  var end = types.length;\n  var areAllMaybes = false;\n  for (var i = end - 1; i >= 0; i--) {\n    var type = types[i];\n    if (!isType(type) || type.meta.kind !== 'maybe') {\n      return (i + 1);\n    } else {\n      areAllMaybes = true;\n    }\n  }\n  return areAllMaybes ? 0 : end;\n}\n\nfunction func(domain, codomain, name) {\n\n  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)'; });\n    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(domain, codomain);\n  var domainLength = domain.length;\n  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);\n\n  function FuncType(value, path) {\n\n    if (!isInstrumented(value)) { // automatically instrument the function\n      return FuncType.of(value);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });\n    }\n\n    return value;\n  }\n\n  FuncType.meta = {\n    kind: 'func',\n    domain: domain,\n    codomain: codomain,\n    name: name,\n    identity: true\n  };\n\n  FuncType.displayName = displayName;\n\n  FuncType.is = function (x) {\n    return isInstrumented(x) &&\n      x.instrumentation.domain.length === domainLength &&\n      x.instrumentation.domain.every(function (type, i) {\n        return type === domain[i];\n      }) &&\n      x.instrumentation.codomain === codomain;\n  };\n\n  FuncType.of = function (f, curried) {\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)'; });\n      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)'; });\n    }\n\n    if (FuncType.is(f)) { // makes FuncType.of idempotent\n      return f;\n    }\n\n    function fn() {\n      var args = Array.prototype.slice.call(arguments);\n      var argsLength = args.length;\n\n      if (process.env.NODE_ENV !== 'production') {\n        // type-check arguments\n        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);\n        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);\n      }\n\n      if (curried && argsLength < domainLength) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName);\n        }\n        var g = Function.prototype.bind.apply(f, [this].concat(args));\n        var newDomain = func(domain.slice(argsLength), codomain);\n        return newDomain.of(g, true);\n      }\n      else {\n        return create(codomain, f.apply(this, args));\n      }\n    }\n\n    fn.instrumentation = {\n      domain: domain,\n      codomain: codomain,\n      f: f\n    };\n\n    fn.displayName = getFunctionName(f);\n\n    return fn;\n\n  };\n\n  return FuncType;\n\n}\n\nfunc.getDefaultName = getDefaultName;\nfunc.getOptionalArgumentsIndex = getOptionalArgumentsIndex;\nmodule.exports = func;\n"]},"metadata":{},"sourceType":"script"}