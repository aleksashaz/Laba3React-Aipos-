{"ast":null,"code":"var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nvar isArray = require('./isArray');\n\nfunction getDefaultName(type) {\n  return 'Array<' + getTypeName(type) + '>';\n}\n\nfunction list(type, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () {\n      return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(type);\n  var typeNameCache = getTypeName(type);\n  var identity = isIdentity(type); // the list is identity iif type is identity\n\n  function List(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isArray(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')';\n      });\n    }\n\n    var idempotent = true; // will remain true if I can reutilise the input\n\n    var ret = []; // make a temporary copy, will be discarded if idempotent remains true\n\n    for (var i = 0, len = value.length; i < len; i++) {\n      var actual = value[i];\n      var instance = create(type, actual, process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null);\n      idempotent = idempotent && actual === instance;\n      ret.push(instance);\n    }\n\n    if (idempotent) {\n      // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  List.meta = {\n    kind: 'list',\n    type: type,\n    name: name,\n    identity: identity\n  };\n  List.displayName = displayName;\n\n  List.is = function (x) {\n    return isArray(x) && x.every(function (e) {\n      return is(e, type);\n    });\n  };\n\n  List.update = function (instance, patch) {\n    return List(assert.update(instance, patch));\n  };\n\n  return List;\n}\n\nlist.getDefaultName = getDefaultName;\nmodule.exports = list;","map":{"version":3,"sources":["/home/aleksashaz/Aipos/Laba3React-Aipos-/node_modules/tcomb/lib/list.js"],"names":["assert","require","isTypeName","isFunction","getTypeName","isIdentity","create","is","isArray","getDefaultName","type","list","name","process","env","NODE_ENV","stringify","displayName","typeNameCache","identity","List","value","path","join","idempotent","ret","i","len","length","actual","instance","concat","push","Object","freeze","meta","kind","x","every","e","update","patch","module","exports"],"mappings":"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","sourcesContent":["var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar isFunction = require('./isFunction');\nvar getTypeName = require('./getTypeName');\nvar isIdentity = require('./isIdentity');\nvar create = require('./create');\nvar is = require('./is');\nvar isArray = require('./isArray');\n\nfunction getDefaultName(type) {\n  return 'Array<' + getTypeName(type) + '>';\n}\n\nfunction list(type, name) {\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)'; });\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)'; });\n  }\n\n  var displayName = name || getDefaultName(type);\n  var typeNameCache = getTypeName(type);\n  var identity = isIdentity(type); // the list is identity iif type is identity\n\n  function List(value, path) {\n\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')'; });\n    }\n\n    var idempotent = true; // will remain true if I can reutilise the input\n    var ret = []; // make a temporary copy, will be discarded if idempotent remains true\n    for (var i = 0, len = value.length; i < len; i++ ) {\n      var actual = value[i];\n      var instance = create(type, actual, ( process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null ));\n      idempotent = idempotent && ( actual === instance );\n      ret.push(instance);\n    }\n\n    if (idempotent) { // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  List.meta = {\n    kind: 'list',\n    type: type,\n    name: name,\n    identity: identity\n  };\n\n  List.displayName = displayName;\n\n  List.is = function (x) {\n    return isArray(x) && x.every(function (e) {\n      return is(e, type);\n    });\n  };\n\n  List.update = function (instance, patch) {\n    return List(assert.update(instance, patch));\n  };\n\n  return List;\n}\n\nlist.getDefaultName = getDefaultName;\nmodule.exports = list;\n"]},"metadata":{},"sourceType":"script"}